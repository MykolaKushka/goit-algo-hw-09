У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

    Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
    Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.

## Висновки

Порівняння ефективності

Жадібний алгоритм

    Час виконання: O(n), де n — кількість номіналів монет.
    Просторова складність: O(1) для збереження результату.
    Продуктивність: Дуже ефективний для великих сум, оскільки використовує найменшу кількість ітерацій.
    Недолік: Не завжди дає оптимальне рішення для всіх наборів монет. Наприклад, для монет [9, 6, 1] сума 18 буде оптимальною (дві монети по 9), а жадібний алгоритм може дати 6 + 6 + 6 (три монети).

Алгоритм динамічного програмування

    Час виконання: O(m * n), де m — кількість монет, n — сума.
    Просторова складність: O(n) для масиву dp.
    Продуктивність: Забезпечує оптимальне рішення з мінімальною кількістю монет.
    Недолік: При великих сумах і великій кількості номіналів монет може бути повільнішим через більшу кількість обчислень.

Жадібний алгоритм швидший і простіший у реалізації, але не завжди оптимальний. Алгоритм динамічного програмування повільніший, але завжди знаходить оптимальне рішення. Для невеликих і середніх сум алгоритм динамічного програмування є прийнятним вибором, тоді як для дуже великих сум з простими наборами монет жадібний алгоритм може бути більш ефективним.
